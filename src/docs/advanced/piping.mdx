---
title: Piping
---

There's another kind of Assembly Line, a special kind, for passing data from one BotAction to the next. It's called Pipe. When BotAction's are assembled in a Pipe, the values they return, are "piped" into subsequent BotAction's. Pipes wrap the values resolved from each BotAction, in a branded Pipe object (for type gaurding), then injects the Pipe object at the end of the spread `injects` array for each subsequent BotAction.

This is useful for de-composing implicit functionality that depends on data collected from the page. For example, if a website stores the User auth token in Local Storage, a single a BotAction can get the value, then the next BotAction can operate on it, all through a Pipe. 

## Pipe BotAction

Let's get started with the [pipe()()](/api/assembly-lines#pipe) BotAction to assemble BotAction's for writing and reading to Local Storage:
```typescript
await pipe()(
   setLocalStorageItem('userID', '12345'),
   getLocalStorageItem('userID'),
   log('User ID is in the Pipe') // has '12345' as the Pipe valued logged to console
)(page)
```
[setLocalStorageItem()](/api/local-storage#set-local-storage-item) sets a key/value in Local Storage. It does not return a value. BotAction's assembled in Pipe's don't have to return a value. However, [getLocalStorageItem()](/api/local-storage#get-local-storage-item) reads the value by the `key` provided, then returns it. 

> "Console" BotAction's support logging Pipe values, when assembled in a Pipe, so the [log()](/api/console#log) call seen here, will log in additional statement to the console with the Pipe value of `"12345"`.

`pipe()()()` runs the assembled actions, one at a time, and checks the values returned from each. When a function doesn't return a value, that is considered, emptying the Pipe. Empty pipes are still injected and have an `undefined` value:

```typescript
const anEmptyPipeObject = {
    brand: 'Pipe',
    value: undefined
}
```
When running a `pipe()()` in a context without Piping, `pipe()()()` will inject an empty Pipe object into the first assembled BotAction, unless you override that by passing in a value to in the first `pipe()` call.

## BotAction's specific to Piping

There are a collection of BotAction's specific to Piping: [map()](/api/pipe#map), [pipeValue()](/api/pipe#pipe-value), and [emptyPipe](/api/pipe#empty-pipe). [map()](/api/pipe#map) accepts a pure function to operate on the Pipe value, so if you want to cast the Pipe value from one type to another, use the [map()](/api/pipe#map) BotAction. Let's see an example, `isGuest` from Instagram auth, uses [map()](/api/pipe#map) to convert the Pipe value to the correct boolean value:
```typescript
const isGuest: ConditionalBotAction = 
  indexedDBStore('redux', 'paths')(
    getIndexedDBValue('users.viewerId'),
    map(viewerId => viewerId ? false : true),
  )
```
Here we are getting a value from the `redux` IndexedDB, a store called `paths`, by the key `users.viewerId`. The returned value (Pipe value) is mapped to the correct values for `isGuest`. Basically, if the `viewerId` is defined, then the Bot is considered logged in, therefore `isGuest` is `false` otherwise it is `true`.

## Helpers for Piping

Also, there are separate functions in this library, that are found in the module, that are not BotAction's, but regular functions, to help reduce boilerplate called Helpers. For example, there are many Helper functions for piping.

To name a few, there are `unpipeInjects()`, `removePipe()`, `getInjectsPipeValue()`, `wrapValueInPipe()`, `pipeInjects()`, and so forth. When starting out with piping, the first three are the most relevant as they help write pipeable BotAction's that can be still be used safely in a Chain.

If you're not interested in whats injected, but need the Pipe value, use `getInjectsPipeValue()` as it has safe fallbacks for when there is no Pipe, in case the BotAction is assembled in a Chain. See the Local Storage BotAction's for examples, in how it's used.

If you're interested in the injects and the Pipe value, use `unpipeInjects()`, which allows you to specify the number of `injects` you're expecting, to safely retrieve them with the Pipe value, even if there was no Pipe, or some `injects` didn't get injected. See the IndexedDB BotAction's for examples.

If you just want the `injects` without any Pipe, use `removePipe()`.