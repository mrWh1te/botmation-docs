---
title: Error Handling
---

Error handling was omitted from Botmation's core. Assembly Lines don't catch errors, and this was done in favor of creating a composable solution for helping devs find errors in deeply nested assembly lines.

Debugging async code is hard & time consuming. The solution catchs errors and helps narrow where they are coming from in complex lines of BotAction's. The solution is another BotAction called `errors()()`.

## Errors BotAction

`errors()()` wraps assembled BotAction's in a try/catch, where errors caught are logged to the NodeJS console with the "Errors Block Name" provided in the first `errors()` call. Let's see an example:

```typescript
await chain(
    errors('News Scraper')(
        // actions here are ran in a wrapped try/catch:
        goTo('site to scrape'),

    ),
    log('this runs, even if errors()() catches an error')
)(page)
```
So if any actions in the assembled `errors()()` second call throws an error, the error is caught by the `errors()()` BotAction, logged to the NodeJS console with it's block name. After an error is thrown, the remaining assembled actions assembled are ignored, and the higher line continues. So if an error is caught in the "News Scraper" block, the `log()` function will still run.

## Nesting to isolate errors
`errors()()` is nestable as deeply as necessary. This helps isolate the origins of tough to find async errors. The closest parent `errors()()` block will swallow the thrown error. Therefore, `errors()()` can "block" your code, in any context, into separate identifiable parts, for isolating async errors.

## Works in Pipe or Chain

`errors()()` checks the higher order context `injects` for a Pipe object, to determine how it runs the assembled actions. If a Pipe object is detected, it runs its actions in a Pipe otherwise in a Chain. This keeps the style of BotAction assembly consistent with the parent context.