---
title: Advanced
---

There's a lot more you can do with Botmation, given the composable nature of BotAction's. For starters, BotAction's have an optional param, yet to be mentioned that's part of a higher order system, called `injects`.

## Injects

Let's take a look at the actual BotAction Function interface:
```typescript
interface BotAction<R = void, I extends Array<any> = any[]> extends Function {
  (page: Page, ...injects: I) : Promise<R>
}
```

See, there is a second param, after `page` called `injects` which, by default, is a spread array of `any`. It's optional, you don't have to use it. But, it can be handy. All Assembly Lines supports the `injects` system.

If you need to provide an object(s), value(s), service(s), etc. consistently to a line of BotAction's, you can do so by injecting them. Let's see how we inject them in the first place:

```typescript
const service = new ServiceA()
const todaysDate = new Date()

await chain(
    // ... actions
)(page, service, todaysDate)
```

The assembled BotAction's in the `chain()` will be called with `service` and `todaysDate` as the second and third parameters.

Now, what if you want to compose a line of actions, but with new injects? You can use the `inject()()` BotAction to pass in new injects, prepended to the higher level injects. A few BotAction's are composed with `inject()()` like `files()()` and `indexedDBStore()()`. Those composed BotAction's inject the first few `injects` provided in the first `inject()` call then pass in the other injects from the higher context, for the declared BotAction's.

Here's an example:
```typescript
const generalService = new GeneralService()
const specialService = new SpecialService()

await chain(
    inject(specialService)(
        goTo('http://example.com/special-page.html'),
        doSomethingSpecial()
        // these actions have `specialService` as their 1st inject
        // and `generalService` as their 2nd inject
    ),
    log('some message') // this log() BotAction will NOT have `specialService` injected
                        // but, will still have `generalService` as its 1st inject
)(page, generalService)
```
This gives granular control of what's passed in the spread `injects` array for assembled BotAction's.

## Piping

There's another kind of Assembly Line, a special kind, for passing data from one BotAction to the next. It's called Pipe. When BotAction's are assembled in a Pipe, the values they return, are "piped" into subsequent BotAction's. This means the Pipe wraps the values resolved from each BotAction, in a branded Pipe object (for type gaurding), called Pipe then injects the Pipe object at the very end of the spread `injects` array.

This is useful for sharing data, like data scraped from a web page. For example, what if a website stored an auth token in Local Storage? With a Pipe, a BotAction can get the value, then other BotAction's can operate on it through a Pipe. That's where Piping comes in, as it allows a BotAction to return a value for the next BotAction to operate with.

Let's get started with a simple example of writing and reading a value to Local Storage:
```typescript
await pipe()(
   setLocalStorageItem('userID', '12345'),
   getLocalStorageItem('userID'),
   log('User ID is in the Pipe') // has '12345' as the Pipe valued logged to console
)(page)
```
Now, instead of diving into Local Storage BotAction's, let's consider what's happening in the context of this Pipe. `setLocalStorageItem()` sets a key/value in Local Storage, and does *not* return a value. However, `getLocalStorageItem()` reads the value by the `key` provided, then returns the value found. 

> "Console" BotAction's support logging Pipe values, when a Pipe is present, so the `log()` call seen here, will log in additional statement to the console with Pipe value of `"12345"`.

`pipe()()()` runs the assembled actions, one at a time, and checks the values returned from each. When a function doesn't return a value, that is considered, emptying the Pipe. Empty pipes are still injected. They look like this:

```typescript
const anEmptyPipe = {
    brand: 'Pipe',
    value: undefined
}
```
When running a `pipe()()` in a context without one, `pipe()()()` will inject an empty one into the first assembled BotAction, unless you override that by passing in a value to Pipe in the first `pipe()` call.

No matter what, there is always a Pipe appended at the end of the `injects`, when BotAction's are assembled in a Pipe.

There are a collection of BotAction's specific to piping: `map()`, `pipeValue()`, and `emptyPipe`. `map()` accepts a pure function to operate on the Pipe value, so if you want to cast the Pipe value from one type to another, use the `map()` BotAction. Let's see an example, `isGuest` from Instagram auth, uses `map()` to convert the Pipe value to the correct boolean value:
```typescript
const isGuest: ConditionalBotAction = 
  indexedDBStore('redux', 'paths')(
    getIndexedDBValue('users.viewerId'),
    map(viewerId => viewerId ? false : true),
  )
```
Here we are getting a value from the `redux` IndexedDB, a store called `paths`, by the key `users.viewerId`. The returned value (Pipe value) is mapped to the correct values for `isGuest`. Basically, if the `viewerId` is defined, then the Bot is considered logged in, therefore `isGuest` is `false` otherwise it is `true`.

Also, there are separate functions in this library, that are found in the module, that are not BotAction's, but regular functions, to help reduce boilerplate called Helpers. For example, there are many Helper functions for piping.

To name a few, there are `unpipeInjects()`, `removePipe()`, `getInjectsPipeValue()`, `wrapValueInPipe()`, `pipeInjects()`, and so forth. When starting out with piping, the first three are the most relevant as they help write pipeable BotAction's that can be still be used safely in a Chain.

If you're not interested in whats injected, but need the Pipe value, use `getInjectsPipeValue()` as it has safe fallbacks for when there is no Pipe, in case the BotAction is assembled in a Chain. See the Local Storage BotAction's for examples, in how it's used.

If you're interested in the injects and the Pipe value, use `unpipeInjects()`, which allows you to specify the number of `injects` you're expecting, to safely retrieve them with the Pipe value, even if there was no Pipe, or some `injects` didn't get injected. See the IndexedDB BotAction's for examples.

If you just want the `injects` without any Pipe, use `removePipe()`.

## Conditionals

What if you want to run an assembly line of actions, but only after finding something in the Page to be true? Botmation has you covered with a special type of BotAction called Utilities.

Let's get started with the simplest one, called `givenThat()()`, a functional if statement.

Here's a simplified bit of code from the Instagram example that attempts to login, only, *if* the Bot is a Guest:

```typescript
await chain(
    // "Console" BotAction
    log('Bot is running aka User'),

    // "Utility" BotAction givenThat() 
    //    Resolves a "Conditional" BotAction for a boolean value
    //    Only if that value equals TRUE, then the actions assembled are ran
    givenThat(isGuest)(
        log('is guest so logging in'),
        login({username: 'account', password: 'password'}),
    ),

    givenThat(isLoggedIn)(
        log('Bot is logged in')
    )
)(page)
```

`givenThat()` accepts a special kind of BotAction called `ConditionalBotAction`. Therefore, `isGuest` and `isLoggedIn` are actually BotAction's with stricter typing that returns a boolean value. If the value returned is `true`, then the assembled actions are ran in a Pipe.

So what happens is that `givenThat()` resolves the `ConditionalBotAction` which can be a complex composition of actions to determine something, in this case whether or not the Bot is logged in.

## Looping

What about running the same scraping BotAction or actions in a for loop against an array of website url's? It's a common web scraping scenario. Botmation has you covered. From the BotAction's type "Utilities" exists a useful BotAction called `forAll()()` that will iterate a collection (either an object's key/value pairs or an array's values) against a callback function that returns a BotAction or an array of BotAction's.

Let's see an example:
```typescript
await chain(
    forAll(['google', 'facebook'])(
        (siteDomain) => ([ // name the var whatever desired in the closure
            goTo('http://' + siteDomain + '.com'),
            screenshot(siteDomain + '-homepage')
        ])
    )
)(page)
```
Here we pass in a collection, an array of site domain's in the first call of `forAll()` then in the second call pass in an anonymous function, a closure, which gets called on each iteration of the collection, which in this case is once for each site domain in the array.

When this `forAll()()` completes, it will have visted and taken screenshots of each domain in the array, in the order declared. See documentation for more details & examples.

## Error Handling

Error handling has been omitted entirely from the library's core. Assembly Lines don't try to catch any errors, and this was done in favor of creating a simple composable solution for finding errors in deeply nested assembly lines. Debugging async code is hard & time consuming. So a solution was designed to help narrow down thrown errors to the exact BotAction. This is done with a special type of BotAction, called `errors()()`.

`errors()()` wraps assembled BotAction's in a try/catch, where errors caught are logged to the console with the Errors Block Name provided in the first `errors()` call. Let's see an example:

```typescript
await chain(
    errors('A specific error block name')(
        // actions to run in a wrapped try/catch:
        goTo('site to scrape'),
        // ... 
    ),
    log('this runs, even if errors()() catches an error')
)(page)
```
So if any actions in the assembled `errors()()` call throws an error, the error is caught by the `errors()()` BotAction and then logged to the console with the Error Block Name provided. After an error is thrown, the remaining assembled actions assembled are ignored (they don't run), but the higher order assembly-line continues.

`errors()()` checks the higher order context `injects` for a Pipe, and runs the assembled actions in a Pipe, only if a Pipe was detected. It tries to keep the style of assembly consistent.

Also, you can nest `errors()()` as deeply as you want. This is to help isolate, tough to find async bugs, in deeply nested assembly lines. Make sure to give each one an uniquely identifying Error Block Name, so you can identify where the error was caught. If a nested `errors()()` catches a thrown error, it swallows it, so higher level `errors()()` will not see it. This helps isolate bugs in the async functionality.