---
title: 'Overview'
---

Botmation is simple functional framework for building web bots with reusable parts called BotAction's.

> “Everything should be made as simple as possible, but no simpler.” - Albert Einstein

BotAction's are async functions that handle various tasks in the web, from specific to broad. They are *composable*, in that they can be combined, and are easily assembled to be ran as web bots.

Imagine a line of people at a coffee shop. As the line forms, the last person who enters the shop joins the end of the line. The first person in is served first. Classic, first come, first served. BotAction's are assembled like that, they run in the order declared, from first to last. Let's take the metaphor further, any one of those people in the line, can actually represent a whole other line of people, and infinitely deep. It doesn't matter, because a BotAction can be a small specific operation or a line of other BotAction's. 

The possibilities are endless.

> If you are new to Functional programming, but are familiar with Object-Oriented, consider this. Functional programming replaces Classes with a composable system for assembling functions together, like building blocks, to *compose* bigger functions as instances of Classes, using only the functionality required. The pattern removes Classes as a code sharing barrier and minimizes runtime overhead.

## BotAction Functions
A BotAction is an async function that does one task, small or big. For example, change the page URL, take a screenshot of the window, type something with a keyboard, click something with a mouse, manage your Instagram account (login, like friends' posts), run all the tasks of a bot by managing multiple online identities, etc. When these functions are assembled together, like building blocks, their entire functional composition becomes the bot that crawls the web, performing tasks it was declared to do.

BotAction's are organized by type. Some BotAction's are very simple, they operate directly with a Puppeteer `page`. Others are more complex with higher-order functions. More on that later.

## Running BotAction's

Since, BotAction's are async functions, all you need to do, in order to run one, is to resolve their returned Promise.

> If you're unfamiliar with async functions in JavaScript, they are simply functions that return Promises. Promises is a way to handle async functionality like reacting to events when you don't know when they'll take place. This is important since a lot of Puppeteer's API is asynchronous.

For example, this is how you run the `goTo()` & `waitForNavigation` BotAction's:
```typescript
const page = await browser.newPage() // Puppeteer Browser

await goTo('https://example.com')(page)
await waitForNavigation(page)
```
`goTo()` is a higher-order sync function, that accepts the URL to navigate the `page` too. It returns a BotAction, customized with the URL to navigate the page too.

In contrast, `waitForNavigation` is a BotAction that does not need any customization, so it isn't wrapped in any higher-order functions. Simplicity is good.

## Building Bot's

Bots are built by assembling BotAction's in a line. Let's change the example above by assembling the two BotAction's with an Assembly-Line BotAction.

Assembly Lines assemble BotAction's in the sequence declared, one by one, for running the line of async functionality as a single BotAction. The simplest one is called `chain()()`.

```typescript title=playground_bot.ts
const page = await browser.newPage()

await chain(
  goTo('https://example.com'),
  waitForNavigation
)(page)
```

Here a Bot is assembled with a single line, chain, of BotAction's. The Bot will first navigate to the URL provided, then wait for navigation to complete. As you can see, we write "await" only only once for the Bot, and not for each step. Also, each BotAction is assembled instead of resolved. `chain()`'s first call assembles declared BotAction's in line for running later in the returned BotAction, the second call `chain()()`, which we `await`.

Let's break up the example into a few more lines of code, to help see:
```typescript
const page = await browser.newPage()

const bot = chain(
  goTo('https://example.com'),
  waitForNavigation
)

await bot(page) // <- run the BotAction
```

`chain()` returns a BotAction, and that BotAction will run the BotAction's in the line declared. So `bot` is an async function, composed from other async functions, all called BotAction's.

Bot's are BotAction's and are usually made from an Assembly Line BotAction, but are not limited too.

## Making Simple BotAction's

There's three distinct ways to write a BotAction, from simplest to most complex.

The simplest kind of BotAction is one that has no higher order sync functions that customize the async functionality. It's just a single async function. Let's take a look at a familiar example, from "Navigation", called `waitForNavigation`:

```typescript
const waitForNavigation: BotAction = async(page) => {
  await page.waitForNavigation()
}
```

This is as simple as it gets. There are no additional layers of functions to customize the BotAction, as you can see, it is a single async function that takes a Puppeteer `page` param. Simplicity is great.

## Making Dynamic BotAction's

Now what if you want to create a BotAction that is more dynamic, say customizable? You wrap the async function with higher-order sync functions. Let's take a closer look at `goTo()`, from "Navigation", that navigates the page to a new URL:

```typescript
const goTo = (url: string, goToOptions?: Partial<DirectNavigationOptions>): BotAction => 
  async(page) => {
    goToOptions = enrichGoToPageOptions(goToOptions)  

    // same url check
    if (page.url() === url) {
      return
    }

    await page.goto(url, goToOptions)
  }
```

As we see here, a single higher-order sync function has two params, `url` and `goToOptions?` that are used in the returned BotAction. They are for customizing the async functionality.

The higher order parameters can be whatever you need them to be. They're typed as a spread array of `any`, so add more if you need more. Also, you are not limited to only one higher-order sync function, so stack them up, as high as need be! The possibilities are boundless.

## Composing BotAction's

Now what if you want to create a BotAction that handles a broad task of operations like in a complicated feature. This BotAction will need to run a bunch of other BotAction's, in order to complete its task. Almost like a mini-bot, but for reusability sakes, let's make it as its own BotAction for assembly by any bots.

We compose a BotAction with other BotAction's higher-order functions without resolving the returned BotAction.

Let's get started with a common scenario, like a `login()` BotAction for a basic form:

```typescript
const login = ({username, password}: {username: string, password: string}): BotAction =>
  chain(
    goTo('https://example.com/login.html'),
    click('form input[name="username"]'),
    type(username),
    click('form input[name="password"]'),
    type(password),
    click('form button[type="submit"]'),
    waitForNavigation,
    log('Login Complete')
  )
```

It looks magical, but the typing keeps it all in check for us.

`login()` is a higher-order function that provides customization for the form's entered `username` and `password` values. It returns a BotAction, a chain of other BotAction's that are resolved one at a time, before the next BotAction.

Here, we see only one call of `chain()` (the sync call), and don't see the second call of `chain()()` (the async BotAction call). That's because, we don't want too here. We're not running the bot just yet, but building a bot part to handle logging in. The second call of `chain()()` is the BotAction that we are returning. Therefore, `login()`'s BotAction is a line of other BotAction's. It's a composition.

If you're worried about remembering when to make the first call or the second, don't. Botmation has your back with strong typing that will catch these errors, and more, in your IDE Intellisense (or during build).

Moving forward, consider your web crawling tasks as multiple distinct steps that can be parts of many bots, each a separate BotAction that is simple to test, and compose in any solution for any web crawling problem.