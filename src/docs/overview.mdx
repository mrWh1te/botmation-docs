---
title: 'Overview'
---

Botmation is simple declarative framework for building web bots with reusable functions called BotAction's.

> ‚ÄúEverything should be made as simple as possible, but no simpler.‚Äù - Albert Einstein

<img src="/orange_bot.png" alt="Orange Bot" align="right" width="150px" />

BotAction's are async functions that handle various tasks in the web, from specific to broad. They are *composable*, in that they can be created from higher order functions, and are easily assembled into web bots. They are like bricks, you can lay them down to build walls in any direction.

Imagine a line of people at a coffee shop ‚òï. As the line forms, the last person who enters the shop joins the end of the line. The first person served is the first person in line. 

> Classic, first come, first served

Botmation bots work like that. They run the BotAction's in the declared order, from first to last.

Let's take the metaphor further, into Alice in Wonderland... come follow the white rabbit üêá for a second.

In Botmation, any one of those people in line üßç, can actually be a whole other line of people üßëüèæ‚Äçü§ù‚Äçüßë. Then any one of those people in this deeper line can also be a whole other line of people üßëüèæ‚Äçü§ù‚Äçüßëüßëüèæ‚Äçü§ù‚Äçüßë, and infinitely deep ‚ôæÔ∏è. It doesn't matter, because a BotAction can be a small specific async operation or a line of other BotAction's.

The possibilities for assembling bots are endless.

> If you are new to Functional programming, but are familiar with Object-Oriented, consider this. Functional programming replaces Classes with a composable system for assembling functions together, like building blocks, to *compose* bigger functions as instances of Classes, using only the functionality required. The pattern removes Classes as a code sharing barrier and minimizes runtime overhead.

## What is a BotAction?
A BotAction is a web bot part. They can be assembled together, like building blocks, to build web bots and compose bigger BotAction's.

A BotAction is an async function that does one task, small or big. For example, change the page URL, take a screenshot of the window, type something with a keyboard, click something with a mouse, manage your Instagram account (login, like friends' posts), run all the tasks of a bot by managing multiple online identities, etc.

BotAction's are organized by type. Some are simple, while others are complex. They can be customized with higher-order functions and composed with other BotAction's. More on that later.

## Running BotAction's

BotAction's are ran to completion by resolving their returned Promise.

> If you're unfamiliar with async functions in JavaScript, they are simply functions that return Promises. Promises is a way to handle async functionality like reacting to events when you don't know when they'll take place. This is important since a lot of Puppeteer's API is asynchronous.

Some BotAction's are returned from higher-order functions whose params make the BotAction customizable.

For example, this is how you run the `goTo()` & `waitForNavigation` BotAction's:
```typescript
const page = await browser.newPage() // Puppeteer Browser

await goTo('https://example.com')(page)
await waitForNavigation(page)
```
`goTo()` is a higher-order sync function, that accepts the URL to navigate the `page` too then returns the customized BotAction, to perform that specific page navigation.

In contrast, `waitForNavigation` is a BotAction that does not need any customization, so it isn't wrapped in any higher-order functions. It is simply resolved.

## Building Bots

Bots are built by assembling BotAction's in a line. Let's change the example above into a complete web bot by assembling the two BotAction's with a special kind of BotAction called an Assembly Line. Let's use the simplest one called `chain()()`:

```typescript
const page = await browser.newPage()

await chain(
  goTo('https://example.com'),
  waitForNavigation
)(page)
```

This bot is assembled with a chain of BotAction's. The bot will first navigate to the URL provided, then wait for navigation to complete. As you can see, we write "await" only once for the bot, and not for each step. That's because we are composing complex async functionality with higher order sync functions.

Let's break up the example into a few more lines of code, to help see:
```typescript
const page = await browser.newPage()

// chain() returns composed BotAction
const bot: BotAction = chain(
  goTo('https://example.com'),
  waitForNavigation
)

await bot(page) // <- run the BotAction, now bot
```

The first call of `chain()` returns a BotAction, composed of a chain of other BotAction's to run. Therefore, `bot` is a BotAction composed by higher-order sync functions. It creates a composition of async functionality in a single function.

A BotAction can be a single thing or an assembled line of other BotAction's, therefore a BotAction can be a bot or just a bot part. Philosophically, BotAction's are nothing but web bot parts, until they are ran, either individually or in a composition.

## Making Simple BotAction's

There's three distinct ways to code a BotAction, from simplest to most complex.

The simplest kind of BotAction is one that has no higher order sync functions that customize the async functionality. It's just a single async function. Let's take a look at a familiar example, from "Navigation", called `waitForNavigation`:

```typescript
const waitForNavigation: BotAction = async(page) => {
  await page.waitForNavigation()
}
```

This is as simple as it gets. There are no additional layers of functions to customize the BotAction, as you can see, it is a single async function that takes a Puppeteer `page` param to operate on. Simplicity is great.

## Making Dynamic BotAction's

Now what if you want to create a BotAction that is more dynamic, say customizable? You wrap the async function with higher-order sync functions then use their params to customize the async functionality. Let's take a closer look at `goTo()`, from "Navigation", that navigates the page to a new URL:

```typescript
const goTo = (url: string, goToOptions?: Partial<DirectNavigationOptions>): BotAction => 
  async(page) => {
    goToOptions = enrichGoToPageOptions(goToOptions)  

    // same url check
    if (page.url() === url) {
      return
    }

    await page.goto(url, goToOptions)
  }
```

As we see here, a single higher-order sync function has two params, `url` and `goToOptions?` that are used in the returned BotAction. They customize the async functionality during assembly.

The higher order parameters can be whatever you need them to be. They're typed as a spread array of `any`, so add more if you need more. Also, you are not limited to only one higher-order sync function, so stack them up, as high as need be! The possibilities are endless.

## Composing BotAction's

With higher-order based BotAction's, you can use them to compose new BotAction's, ie:
```typescript
const goToGoogle: BotAction = async(page) => 
  goTo('https://google.com')
```

Now what if you want to create a BotAction that handles a broad task with multiple steps. A BotAction that will run other BotAction's, in order to complete its task.

To do this, we compose a new BotAction using an Assembly Line BotAction.

Let's get started with a common scenario, like a `login()` BotAction for a basic form:

```typescript
const login = (username: string, password: string): BotAction =>
  chain(
    goTo('https://example.com/login.html'),
    click('form input[name="username"]'),
    type(username),
    click('form input[name="password"]'),
    type(password),
    click('form button[type="submit"]'),
    waitForNavigation,
    log('Login Complete')
  )
```

It looks magical, but the strong typing keeps it all in check for us.

`login()` is a higher-order sync function that composes a chain of BotAction's to run in a line. This works because the first call of `chain()` returns a BotAction. The second call of chain is the async BotAction that runs the declared BotAction's with the customizing parameters from the the higher-order `login()` function.

This BotAction completes a login flow for a common website form. It starts by going to the login page, entering the `username` and `password` into the login page's form, then submits the form, and finally waits for the Navigation of the page to complete, before logging `Login Complete` in the NodeJS console.