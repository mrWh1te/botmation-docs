---
title: 'Overview'
---

Botmation is a simple declarative framework for building web bots with composable functions called BotAction's.

> ‚ÄúEverything should be made as simple as possible, but no simpler.‚Äù - Albert Einstein

<img src="/orange_bot.png" alt="Orange Bot" align="right" width="150px" />

BotAction's are async functions that handle various tasks in the web, from specific things like "click this button" to broad flows like "scrape this feed and like my friends' posts". They are *composable*. They can be assembled and created from higher order functions. They are like bricks, you can lay them down to build walls, then use the walls to build buildings, then use the buildings to build cities and so forth.

Imagine a door into a coffee shop ‚òï. As üßç üßç üßç customers enter, a üßçüßçüßç line forms. The first customer in is served first then the next and the next.

BotAction's are declared in lines like that. They run from first to last.

But wait, there's more. Any üßç person in üßçüßçüßç line, can actually be a whole other üßçüßçüßç line of people. And any one of those people in this "child" line, can be a whole other üßçüßçüßç line of people, and so and so forth ‚ôæÔ∏èüêá. It's all composable, partly because all these async functions follow the BotAction interface. A BotAction can be a specific async operation or it can be a whole other line of BotAction's.

The possibilities are endless.

Imagine a gold chain of separate links. Each link in the chain represents a BotAction. And any link in the chain, can be another chain of links, infinitely deep. Each link is self-reliant, they don't need other links to operate. Each link in the chain is ran, one at a time, in-order, until each async function resolves. So happenly, a single link, can be a whole tree of chains and links representing a complex flow of async functionality. It can all be put together in any way you like, there are no limits.

> If you are new to Functional programming, but are familiar with Object-Oriented, consider this. Functional programming replaces OO classes with a composable function system for building bigger functions, like building blocks, provide the utility of OO class instances, while using only the functionality required. The pattern removes classes as a code sharing barrier and minimizes runtime overhead.

## What is a BotAction?
BotAction's are building blocks for assembling web bots.

They are async functions that do things, big or small. For example, they can change the page URL, take a screenshot of the window, type a comment with a keyboard, click a button with a mouse, manage your Instagram account (login, like friends' posts), run all the tasks of your bot in managing multiple online identities, etc.

BotAction's are organized by type, listed under API in this site's navigation. It is not necessary to learn them all, but only what you need.

## Running BotAction's

BotAction's are ran by resolving their returned Promise.

> If you're unfamiliar with async functions in JavaScript, they are simply functions that return Promises. Promises is a way to handle async functionality like reacting to events when you don't know when they'll take place. This is important since a lot of Puppeteer's API is asynchronous.

Some BotAction's are returned from higher-order functions whose params customize the BotAction.

For example, this is how you run the `goTo()` & `waitForNavigation` BotAction's:
```typescript
const page = await browser.newPage() // Puppeteer Browser

await goTo('https://example.com')(page)
await waitForNavigation(page)
```
`goTo()` is a higher-order sync function, that accepts the URL to navigate the `page` too then returns the customized BotAction, to perform that specific page navigation.

In contrast, `waitForNavigation` is a BotAction that does not need any customization, so it isn't wrapped in any higher-order functions. It is simply resolved.

## Building Bots

Bots are built by declaring BotAction's in a line. Let's change the example above into a complete web bot by declaring the two BotAction's with a special kind of BotAction called an Assembly Line. Let's use the simplest one called `chain()()`:

```typescript
const page = await browser.newPage()

await chain(
  goTo('https://example.com'),
  waitForNavigation
)(page)
```

This bot is declared with a chain of BotAction's, using the [Chain](/api/assembly-lines#chain) Assembly-Line. The bot will first navigate to the URL provided, then wait for navigation to complete. As you can see, we write "await" only once for the bot, and not for each step. That's because we are composing an async function, with higher order sync functions, to handle all the tasks.

Let's break up the example into a few more lines of code, to help see:
```typescript
const page = await browser.newPage()

// chain() returns an assembled BotAction
const bot: BotAction = chain(
  goTo('https://example.com'),
  waitForNavigation
)

await bot(page) // <- run the BotAction, now bot
```

The first call of `chain()` is a higher-order sync function that returns a BotAction, composed of a chain of other BotAction's. Therefore, `bot` is an async function to run on any Puppeteer page with all the operations declared in order.

A BotAction can be a single async function or an assembled line of other BotAction's. Therefore, a BotAction is both a bot and a bot part. Philosophically, the way to differentiate is how it's observed, BotAction's are bot parts, until they are ran, either individually or in a composition as a bot.

## Making Simple BotAction's

There's three distinct ways to code a BotAction, from simplest to most complex.

The simplest kind of BotAction is one that has no higher order sync functions that customize the async functionality. It's a simple async function. Let's take a look at a familiar example, from "Navigation", called `waitForNavigation`:

```typescript
const waitForNavigation: BotAction = async(page) => {
  await page.waitForNavigation()
}
```

This is as simple as it gets. There are no additional layers of functions to customize the BotAction, as you can see, it is a single async function that takes a Puppeteer `page` param to operate on. Simplicity is great.

## Making Dynamic BotAction's

Now what if you want to create a BotAction that is dynamic, say customizable? You wrap the async function with a higher-order sync function, to provide dynamically params that can customize the async functionality. Let's take a closer look at `goTo()`, from "Navigation", that navigates the page to the URL param:

```typescript
const goTo = (url: string, goToOptions?: Partial<DirectNavigationOptions>): BotAction => 
  async(page) => {
    goToOptions = enrichGoToPageOptions(goToOptions)  

    // same url check
    if (page.url() === url) {
      return
    }

    await page.goto(url, goToOptions)
  }
```

As we see here, there's a higher-order sync function with two params, `url` and `goToOptions?` that are used in the returned BotAction function. These params customize the async functionality.

The higher order parameters can be whatever you need them to be. They're typed as a spread array of `any`, so add more if you need more. Also, you are not limited to only one higher-order sync function, so stack them up, as high as need be! The possibilities are endless. If you're curious, or looking for ideas, check out the [Utilities BotAction's](/api/utilities) for examples with two higher order sync functions.

## Composing BotAction's

BotAction's that are returned by regular sync higher-order functions can be used to create new BotAction's, that are less dynamic, but more readable:
```typescript
const goToGoogle: BotAction = goTo('https://google.com')
```

Now what if you want to create a BotAction that handles a broad task of multiple steps. A BotAction that is like a bot, it will run other BotAction's, in order to complete its task, to promote code reusabilty.

To do this, compose a new BotAction using an Assembly Line BotAction's higher-order sync function.

Let's get started with a common scenario, like a `login()` BotAction for a basic form:

```typescript
const login = (username: string, password: string): BotAction =>
  chain(
    goTo('https://example.com/login.html'),
    click('form input[name="username"]'),
    type(username),
    click('form input[name="password"]'),
    type(password),
    click('form button[type="submit"]'),
    waitForNavigation,
    log('Login Complete')
  )
```

It looks magical, but the strong typing keeps it all in check.

`login()` is a higher-order sync function that declares a chain of BotAction's to run in a line. This works because the first call of `chain()` is a regular sync function that returns a BotAction. The second call of chain `login()`'s BotAction.

This BotAction completes a login flow for a common website form. It starts by going to the login page, entering the `username` and `password` into the login page's form, then submits the form, and finally waits for the Navigation of the page to complete, before logging `Login Complete` in the NodeJS console.