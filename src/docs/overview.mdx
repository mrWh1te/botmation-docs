---
title: 'Overview'
---

Botmation is a simple, declarative framework to build bots with *composable* functions called **BotActions**.

<blockquote>
    <p style="text-align:center">
        ‚ÄúEverything should be made as simple as possible, but no simpler.‚Äù
        <br />
        <span style="text-align:right;padding-right:8rem;display:block;">~ Albert Einstein</span>
    </p>
</blockquote>

<img src="/orange_bot.png" alt="Orange Bot" align="right" width="150px" />

BotActions are self-reliant, single-purposed, async functions that perform tasks from simple, such as "click this button", to broad complex flows, such as "scrape this feed and like all of my friends' posts". They are ran individually or assembled together in a new BotAction.

> BotActions are like bricks. Bricks build walls,, walls build buildings, buildings build cities and so forth. Except, at each level of composition (brick, wall, building, etc), they are *all* the same *type* of function, a BotAction. Regardless of their compositional complexity, they are all single async functions called BotActions.

Imagine a door üö™ into a coffee shop ‚òï where customers üßç,üßç,üßç enter. As they step inside, a customer line forms üßçüßçüßç. The first customer served, is the first customer in line, then the following, and so forth.

Botmation's bots are *assembled in lines* of BotActions. Assembled bots run their actions in the order declared, from first to last.

A single BotAction can be an assembled line of other BotActions. Therefore, a single person üßç in the coffee shop ‚òï, can actually be a whole other line of people üßçüßçüßç. Then any one of those people üßç in this "sub" line üßçüßçüßç, can be a whole other line of people üßçüßçüßç infinitely deep ‚ôæÔ∏èüêá.

The possibilities are endless!

> If you're familiar with de-coupling functionality, this compositional pattern creates structure to keep all units of functionality separated, pluggable and 100% reusable.

## Running BotActions

BotActions wrap a Puppeteer [Page](https://pptr.dev/#?product=Puppeteer&show=api-class-page) instance as a function param. They are completed once their returned promise resolves.

Some BotActions have higher-order functions that customize their functionality. For example, the BotAction [goTo()](/api/navigation/#go-to) uses a higher-order function to set the URL for the bot to navigate too, while [waitForNavigation](/api/navigation/#wait-for-navigation) does not:
```typescript
const page = await browser.newPage() // Puppeteer Browser

await goTo('https://example.com')(page) // call higher-order to get the BotAction
await waitForNavigation(page) // no higher-order, just resolve the BotAction
```

> [Higher-order functions](https://en.wikipedia.org/wiki/Higher-order_function) are functions that return a function. Botmation uses higher-order functions to customize BotActions during runtime.

So how is this better than using Puppeteer directly? BotActions can be assembled into new reusable functions, of varying compositional complexity. No matter what, regardless of their complexity, they are *just* single async functions.

## Assembling Bots

Bots are built by assembling BotActions in a line. This works declaratively, making each bot's code highly readable.

Let's edit the code from the example above, by assembling it into a reusable bot via a special kind of BotAction, an [Assembly Line](/api/assembly-lines). The simplest is called [chain()()](/api/assembly-lines#chain):

```typescript
const bot = chain(
  goTo('https://example.com'),
  waitForNavigation
)
```

This BotAction [chains](/api/assembly-lines#chain) BotActions together, in a single line, as a new reusable BotAction.

> This is inspired by [Currying](https://en.wikipedia.org/wiki/Currying) in Functional Programming.

Now let's run the bot:
```typescript
const bot = chain(
  goTo('https://example.com'),
  waitForNavigation
)

const page = await browser.newPage()
await bot(page)
```

This bot function can be reused on multiple Puppeteer pages. We can even run multiple bots [concurrently](/topic/concurrency), using the same code.

> An assembled bot is still a BotAction. But, a BotAction is a bot part. Philosophically speaking, parts and bots are differentiated via observation. BotActions are bot parts, until they are ran as a bot, either individually or in an assembled composition.

So how do we create our own BotActions that go beyond the functionality provided by Botmation?

## Making Simple BotActions

There's three main ways to write BotActions, from simplest to most complex.

The simplest kind have no higher order functions. They are single async functions. Let's take a look at a familiar example, from [Navigation](/api/navigation), called [waitForNavigation](/api/navigation/#wait-for-navigation):

```typescript
const waitForNavigation: BotAction = async(page) => {
  await page.waitForNavigation()
}
```

There are no higher-order functions wrapping this BotAction. It is a single async function that calls the Puppeteer `page` param's [waitForNavigation function](https://pptr.dev/#?product=Puppeteer&show=api-pagewaitfornavigationoptions). Simplicity is great.

> You can call any Puppeteer page function inside a BotAction. But, you're not limited too just Puppeteer, as you can [inject](/topic/injects) other libraries into your bots. That said, I recommend holding off on learning that until you need it.

## Making Dynamic BotActions

BotActions can be made customizable by wrapping them with a higher-order function. Let's take a closer look at [goTo()](/api/navigation/#go-to) that navigates the page to the URL param provided:

```typescript
const goTo = (url: string, goToOptions?: Partial<WaitForOptions>): BotAction =>
  async(page) => {
    if (page.url() === url) {
      return
    }

    await page.goto(url, enrichGoToPageOptions(goToOptions))
  }
```

[goTo()](/api/navigation/#go-to) uses a higher-order sync function with two params, `url` and `goToOptions?` that customize the returned BotAction function.

The higher order parameters can be whatever you need them to be. They're typed as a spread array of `any`, so add more if you need more. Also, you are not limited to one higher-order sync function. Stack them up, as high as need be! The possibilities are endless. If you're curious, check out the [Loops BotActions](/api/loops) for practical BotActions that wrap themselves with two higher order functions.

## Composing BotActions

BotActions with higher-order functions can be used to create static, more readable BotActions:
```typescript
const goToGoogle = goTo('https://google.com')
```

However, the best has been saved for last! [Assembly Line BotActions](/api/assembly-lines) can be used to compose complex BotActions that handle broad flows that can be reused across all your bots. For example, how about a single BotAction that logs a bot into a website through a Login form?

```typescript
const login = (username: string, password: string): BotAction =>
  chain(
    goTo('https://example.com/login.html'),
    click('form input[name="username"]'),
    type(username),
    click('form input[name="password"]'),
    type(password),
    click('form button[type="submit"]'),
    waitForNavigation,
    log('Login Complete')
  )
```

`login()` is a higher-order sync function that assembles BotActions with the [Chain BotAction](/api/assembly-lines#chain). The first call of [chain()](/api/assembly-lines#chain) is a regular synchronous function that returns a customized BotAction.

This practical BotAction completes a login flow for a common website form. It starts by going to the login page, entering the `username` and `password` into the login page's form's inputs, then submits the form, and finally waits for the Navigation of the page to complete, before logging `Login Complete` in the NodeJS console.
