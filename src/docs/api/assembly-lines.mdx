---
title: 'Assembly Lines'
---

These higher order functions provide a way to assemble other BotAction's declaratively. They are a vital part of Botmation.

## Chain
Imagine a bunch of circular links in a line forming a chain. Each link is a separate BotAction to be run in the order declared. All BotAction's operate in the same Puppeteer `page` provided.

```typescript
const chain =
  (...actions: BotAction[]): BotAction =>
    async(page, ...injects) => {
      if (injectsHavePipe(injects)) {
        if (actions.length === 0) {}
        else if(actions.length === 1) {
          await actions[0](page, ...injects.splice(0, injects.length - 1))
        } else {
          await chainRunner(...actions)(page, ...injects.splice(0, injects.length - 1))
        }
      } else {
        if (actions.length === 0) {}
        else if(actions.length === 1) {
          await actions[0](page, ...injects)
        } else {
          await chainRunner(...actions)(page, ...injects)
        }
      }
    }
```
`chain()` assembled BotAction's in the first call then returns a BotAction to run those declared BotAction's in line. If the Chain detects a [Pipe object](/advanced/piping#pipe-object) in the [injects](/advanced/injects), the Chain removes it from the BotAction's  `injects`.

See [Building Bots](/overview#building-bots) & [Composing BotAction's](/overview#composing-botactions) for usage examples.

## Pipe
Pipes are like Chains except it injects a Pipe object at the end, for all assembled BotAction's. The Pipe object's value is undefined unless a BotAction returns a value. This enables BotAction's to share data forward, to the next BotAction.

```typescript
const pipe =
  (valueToPipe?: any) => 
    (...actions: BotAction<PipeValue|void>[]): BotAction<any> => 
      async(page, ...injects) => {
        if (injectsHavePipe(injects)) {
          if (actions.length === 0) {return undefined}
          if (actions.length === 1) {
            if (valueToPipe) {
              return await actions[0](page, ...injects.splice(0, injects.length - 1), wrapValueInPipe(valueToPipe))
            } else {
              return await actions[0](page, ...injects)
            }
          } else {
            if (valueToPipe) {
              return (await pipeRunner(...actions)(page, ...injects.splice(0, injects.length - 1), wrapValueInPipe(valueToPipe)))
            } else {
              return (await pipeRunner(...actions)(page, ...injects))
            }
          }
        } else {
          if (actions.length === 0) {return undefined}
          else if (actions.length === 1) {
            return await actions[0](page, ...injects, wrapValueInPipe(valueToPipe))
          } else {
            return (await pipeRunner(...actions)(page, ...injects, wrapValueInPipe(valueToPipe)))
          }
        }
      }
```
The first call `pipe()` is for setting or overriding a Pipe object's value (for the first BotAction). The second call `pipe()()` assembles declared BotAction's. The third call `pipe()()()` is the actual BotAction to run the assembled BotAction's with piping.

See [Piping](/advanced/piping) for an usage examples.

## Assembly Line
Assembly Lines are another way to assemble BotAction's for running. They detect the context (the higher line) for [piping](/advanced/piping), and copy what is found. If an Assembly Line is ran inside a Pipe, it will run assembled BotAction's inside a Pipe, otherwise inside a Chain.

The exception to this, is using the first call `assemblyLine(true)` to override that behavior and force the assembled BotAction's to run in a Pipe.
```typescript
const assemblyLine = 
  (forceInPipe: boolean = false) =>
    (...actions: BotAction<any>[]): BotAction<any> =>
      async(page, ...injects) => {
        if (injectsHavePipe(injects) || forceInPipe) {
          // running a pipe
          if (actions.length === 0) {return undefined}
          else if (actions.length === 1) {
            return await actions[0](page, ...pipeInjects(injects))
          } else {
            return await pipeRunner(...actions)(page, ...pipeInjects(injects))
          }
        } else {
          // running a chain
          if (actions.length === 0) {}
          else if (actions.length === 1) {
            await actions[0](page, ...injects)
          } else {
            await chainRunner(...actions)(page, ...injects)
          }
        }
      }
```
The second call `assemblyLine()()` assembles declared BotAction's. The third call `assemblyLine()()()` is the actual BotAction to run the async functionality.

For an usage example, see [inject()()](/api/inject#inject).

## Switch Pipe
Switch Pipes provide a way to assemble BotAction's with the same Pipe object. Each BotAction assembled in the second call of `switchPipe()()` will receive the *same* Pipe value wrapped in the *same* Pipe object, no matter what these BotAction's return.

> Switch Pipe "switches" each Pipe object injected, back to the original one received.

Switch Pipe was built to provide a functional switch statement. Similar to an if statement, a switch statement tests a *case* condition to determine if its code blocks should run, except switch supports multiple cases. Switch Pipe makes this possible by providing the same Pipe object to each BotAction, which then can test or operate on it for each case.

BotAction's like [pipeCase()()](/api/pipe#pipe-case) or [pipeCases()()](/api/pipe#pipe-cases) fit perfectly here. They test the received Pipe object value against its own provided values, to determine if their assembled BotAction's should run. 

Both these functions return a `CasesSignal` that can catalyze Switch Pipe into aborting with one less `assembledLines`.

Switch Pipe has unique aborting functionality that mirrors `break;` inside a switch code block. By default, an AbortLineSignal with `assembledLines` of `1`, is absorbed by Switch Pipe, kind of like it's ignored, until Switch Pipe receives a CasesSignal with `conditionPass` as true.

[pipeCase()()](/api/pipe#pipe-case) and [pipeCases()()](/api/pipe#pipe-cases) return CasesSignal's with `conditionPass` set to `true` when they've ran their assembled BotAction's.

So when an assembled `pipeCase()()` runs its assembled BotAction's, it will catalyze Switch Pipe into lowering the required `assembledLines` count by 1. This enables a conditional breaking of the assembled Switch Pipe line, similar to how a switch, case and break work together.

```typescript
const switchPipe = 
  (toPipe?: PipeValue) => 
    (...actions: BotAction<PipeValue|AbortLineSignal|CasesSignal|void>[]): BotAction<any[]|AbortLineSignal|PipeValue> =>
      async(page, ...injects) => {
        if (!toPipe) {
          toPipe = getInjectsPipeValue(injects)
        }

        if (injectsHavePipe(injects)) {
          injects = injects.slice(0, injects.length - 1)
        }
        injects.push(wrapValueInPipe(toPipe))

        let hasAtLeastOneCaseMatch = false
        const actionsResults = []

        for(const action of actions) {
          let resolvedActionResult = await action(page, ...injects)

          if (isCasesSignal(resolvedActionResult) && resolvedActionResult.conditionPass) {
            hasAtLeastOneCaseMatch = true
            actionsResults.push(resolvedActionResult)
          } else if (isAbortLineSignal(resolvedActionResult)) {
            if (resolvedActionResult.assembledLines === 0) {
              return resolvedActionResult
            }

            if (!hasAtLeastOneCaseMatch) {
              resolvedActionResult = processAbortLineSignal(resolvedActionResult)
            }

            if (!isAbortLineSignal(resolvedActionResult)) {
              actionsResults.push(resolvedActionResult)
            } else if (resolvedActionResult.assembledLines === 1) {
              actionsResults.push(resolvedActionResult.pipeValue)
              return actionsResults
            } else {
              return processAbortLineSignal(resolvedActionResult)
            }
          } else {
            actionsResults.push(resolvedActionResult)
          }
        }

        return actionsResults
      }
```

Except for `abort(0)`, which aborts the entire bot, Switch Pipe absorbs `abort(1)` when no cases have matched. It does this by reducing received AbortLineSignal's `assembledLines` count by 1, when the Switch Pipe has *yet* to receive a CasesSignal with `conditionPass = true`, from an assembled BotAction.

Once Switch Pipe receives a CasesSignal with a true `conditionPass`, it stops pre-processing received AbortLineSignal's, enabling `abort(1)` to break a Switch Pipe line and return the actions' results.

Here's a table to understand it's unique aborting logic. This logic is applied after Switch Pipe subtracts `1` from an AbortLineSignal's `assembledLines` count, if it has yet to have a case match:

| assembledLines | effect                                                         |
|       -        |         -                                                     |
| 0              | don't break Switch Pipe line, append the AbortLineSignal.pipeValue to the returned array                     |
| 1              | break Switch Pipe line, append the AbortLineSignal.pipeValue to the returned array then return that array       |
| 2+              | break Switch Pipe line, return AbortLineSignal with assembledLines reduced by 1         |

For a complete example with pipe casing and aborts, see LinkedIn's Feed BotAction [likeUserPostsFrom()](/sites/linkedin#like-user-posts-from).


## Pipe Action Or Actions
This BotAction fits a niche purpose, of running BotAction's in a Pipe that are returned from a callback function.
```typescript
const pipeActionOrActions = 
  (actionOrActions: BotAction<PipeValue> | BotAction<PipeValue>[]): BotAction<PipeValue|undefined> =>
    async(page, ...injects) => {
      if (Array.isArray(actionOrActions)) {
        return await pipe()(...actionOrActions)(page, ...injects)
      } else {
        return await actionOrActions(page, ...pipeInjects(injects)) // simulate pipe
      }
    }
```
This is a unique kind of Pipe to help when you don't know if you're given an array of BotAction's or just one BotAction. This is different from the common approach of spreading an array of BotAction's.

For an usage example, see [forAll()()](/api/utilities#for-all).

## Runners
These are less optimized, less configurable versions of `chain()` and `pipe()()`. It's recommended to avoid using these directly, but both `chain()()` and `pipe()()()` use them respectively.

### chainRunner
```typescript
const chainRunner =
  (...actions: BotAction[]): BotAction =>
    async(page, ...injects) => {
      for(const action of actions) {
        await action(page, ...injects)
      }
    }
```

### pipeRunner
```typescript
const pipeRunner = 
  <R extends PipeValue = PipeValue, P extends PipeValue = PipeValue>
  (...actions: BotAction<PipeValue|void>[]): BotAction<PipeValue<R>> =>
    async(page, ...injects) => {
      let pipe: Pipe = createEmptyPipe()

      if (injectsHavePipe(injects)) {
        pipe = getInjectsPipeOrEmptyPipe<P>(injects)
        injects = injects.slice(0, injects.length - 1)
      }

      for(const action of actions) {
        const nextPipeValueOrUndefined: PipeValue|void = await action(page, ...injects, pipe)
        pipe = wrapValueInPipe(nextPipeValueOrUndefined as PipeValue|undefined)
      }

      return pipe.value as any as PipeValue<R>
    }    
```