---
title: 'Assembly Lines'
---

These higher order functions provide a way to assemble other BotAction's declaratively. They are a vital part of Botmation.

## Chain
Imagine a bunch of circular links in a line forming a chain. Each link is a separate BotAction to be run in the order declared. All BotAction's operate in the same Puppeteer `page` provided.

```typescript
const chain =
  (...actions: BotAction[]): BotAction =>
    async(page, ...injects) => {
      if (injectsHavePipe(injects)) {
        if (actions.length === 0) {}
        else if(actions.length === 1) {
          await actions[0](page, ...injects.splice(0, injects.length - 1))
        } else {
          await chainRunner(...actions)(page, ...injects.splice(0, injects.length - 1))
        }
      } else {
        if (actions.length === 0) {}
        else if(actions.length === 1) {
          await actions[0](page, ...injects)
        } else {
          await chainRunner(...actions)(page, ...injects)
        }
      }
    }
```
`chain()` assembled BotAction's in the first call then returns a BotAction to run those declared BotAction's in line. If the Chain detects a [Pipe object](/advanced/piping#pipe-object) in the [injects](/advanced/injects), the Chain removes it from the BotAction's  `injects`.

See [Building Bots](/overview#building-bots) & [Composing BotAction's](/overview#composing-botactions) for usage examples.

## Pipe
Pipes are like Chains except it injects a Pipe object at the end, for all assembled BotAction's. The Pipe object's value is undefined unless a BotAction returns a value. This enables BotAction's to share data forward, to the next BotAction.

```typescript
const pipe =
  (valueToPipe?: any) => 
    (...actions: BotAction<PipeValue|void>[]): BotAction<any> => 
      async(page, ...injects) => {
        if (injectsHavePipe(injects)) {
          if (actions.length === 0) {return undefined}
          if (actions.length === 1) {
            if (valueToPipe) {
              return await actions[0](page, ...injects.splice(0, injects.length - 1), wrapValueInPipe(valueToPipe))
            } else {
              return await actions[0](page, ...injects)
            }
          } else {
            if (valueToPipe) {
              return (await pipeRunner(...actions)(page, ...injects.splice(0, injects.length - 1), wrapValueInPipe(valueToPipe)))
            } else {
              return (await pipeRunner(...actions)(page, ...injects))
            }
          }
        } else {
          if (actions.length === 0) {return undefined}
          else if (actions.length === 1) {
            return await actions[0](page, ...injects, wrapValueInPipe(valueToPipe))
          } else {
            return (await pipeRunner(...actions)(page, ...injects, wrapValueInPipe(valueToPipe)))
          }
        }
      }
```
The first call `pipe()` is for setting or overriding a Pipe object's value (for the first BotAction). The second call `pipe()()` assembles declared BotAction's. The third call `pipe()()()` is the actual BotAction to run the assembled BotAction's with piping.

See [Piping](/advanced/piping) for usage examples.

## Assembly Line
```typescript
assemblyLine(forceInPipe: boolean = false) => (...actions: BotAction<any>[]) => BotAction<any>
```
Assembles the declared actions in the second call to run in either a Pipe or a Chain, depending on if the Injects have a Pipe (then run in a Chain) or if the `forceInPipe` value is provided as `true` (then run in a Pipe). If there are no Pipe values, that is considered an empty Pipe.

## Pipe Action Or Actions
```typescript
pipeActionOrActions(actionOrActions: BotAction<PipeValue> | BotAction<PipeValue>[]) => BotAction<PipeValue|undefined>
```
This is a unique kind of Pipe for special cases when you don't know if you're given an array of BotAction's or just one BotAction that is different than the typical spread array of BotAction's. One of the "Utilities" uses this in support of the closure function.