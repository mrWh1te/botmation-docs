---
title: 'Assembly Lines'
---

These higher order functions provide a way to assemble other BotAction's declaratively. They are a vital part of Botmation.

## Chain
Imagine a bunch of circular links in a line forming a chain. Each link is a separate BotAction to be run in the order declared. All BotAction's operate in the same Puppeteer `page` provided.

```typescript
const chain =
  (...actions: BotAction[]): BotAction =>
    async(page, ...injects) => {
      if (injectsHavePipe(injects)) {
        if (actions.length === 0) {}
        else if(actions.length === 1) {
          await actions[0](page, ...injects.splice(0, injects.length - 1))
        } else {
          await chainRunner(...actions)(page, ...injects.splice(0, injects.length - 1))
        }
      } else {
        if (actions.length === 0) {}
        else if(actions.length === 1) {
          await actions[0](page, ...injects)
        } else {
          await chainRunner(...actions)(page, ...injects)
        }
      }
    }
```
`chain()` assembled BotAction's in the first call then returns a BotAction to run those declared BotAction's in line. If the Chain detects a [Pipe object](/advanced/piping#pipe-object) in the [injects](/advanced/injects), the Chain removes it from the BotAction's  `injects`.

See [Building Bots](/overview#building-bots) & [Composing BotAction's](/overview#composing-botactions) for usage examples.

## Pipe
Pipes are like Chains except it injects a Pipe object at the end, for all assembled BotAction's. The Pipe object's value is undefined unless a BotAction returns a value. This enables BotAction's to share data forward, to the next BotAction.

```typescript
const pipe =
  (valueToPipe?: any) => 
    (...actions: BotAction<PipeValue|void>[]): BotAction<any> => 
      async(page, ...injects) => {
        if (injectsHavePipe(injects)) {
          if (actions.length === 0) {return undefined}
          if (actions.length === 1) {
            if (valueToPipe) {
              return await actions[0](page, ...injects.splice(0, injects.length - 1), wrapValueInPipe(valueToPipe))
            } else {
              return await actions[0](page, ...injects)
            }
          } else {
            if (valueToPipe) {
              return (await pipeRunner(...actions)(page, ...injects.splice(0, injects.length - 1), wrapValueInPipe(valueToPipe)))
            } else {
              return (await pipeRunner(...actions)(page, ...injects))
            }
          }
        } else {
          if (actions.length === 0) {return undefined}
          else if (actions.length === 1) {
            return await actions[0](page, ...injects, wrapValueInPipe(valueToPipe))
          } else {
            return (await pipeRunner(...actions)(page, ...injects, wrapValueInPipe(valueToPipe)))
          }
        }
      }
```
The first call `pipe()` is for setting or overriding a Pipe object's value (for the first BotAction). The second call `pipe()()` assembles declared BotAction's. The third call `pipe()()()` is the actual BotAction to run the assembled BotAction's with piping.

See [Piping](/advanced/piping) for an usage examples.

## Assembly Line
Assembly Lines are another way to assemble BotAction's for running. They detect the context (the higher line) for [piping](/advanced/piping), and copy what is found. If an Assembly Line is ran inside a Pipe, it will run assembled BotAction's inside a Pipe, otherwise inside a Chain.

The exception to this, is using the first call `assemblyLine(true)` to override that behavior and force the assembled BotAction's to run in a Pipe.
```typescript
const assemblyLine = 
  (forceInPipe: boolean = false) =>
    (...actions: BotAction<any>[]): BotAction<any> =>
      async(page, ...injects) => {
        if (injectsHavePipe(injects) || forceInPipe) {
          // running a pipe
          if (actions.length === 0) {return undefined}
          else if (actions.length === 1) {
            return await actions[0](page, ...pipeInjects(injects))
          } else {
            return await pipeRunner(...actions)(page, ...pipeInjects(injects))
          }
        } else {
          // running a chain
          if (actions.length === 0) {}
          else if (actions.length === 1) {
            await actions[0](page, ...injects)
          } else {
            await chainRunner(...actions)(page, ...injects)
          }
        }
      }
```
The second call `assemblyLine()()` assembles declared BotAction's. The third call `assemblyLine()()()` is the actual BotAction to run the async functionality.

For an usage example, see [inject()()](/api/inject#inject).

## Pipe Action Or Actions
This BotAction fits a niche purpose, of running BotAction's in a Pipe that are returned from a callback function.
```typescript
const pipeActionOrActions = 
  (actionOrActions: BotAction<PipeValue> | BotAction<PipeValue>[]): BotAction<PipeValue|undefined> =>
    async(page, ...injects) => {
      if (Array.isArray(actionOrActions)) {
        return await pipe()(...actionOrActions)(page, ...injects)
      } else {
        return await actionOrActions(page, ...pipeInjects(injects)) // simulate pipe
      }
    }
```
This is a unique kind of Pipe to help when you don't know if you're given an array of BotAction's or just one BotAction. This is different from the common approach of spreading an array of BotAction's.

For an usage example, see [forAll()()](/api/utilities#for-all).

## Runners
These are less optimized, less configurable versions of `chain()` and `pipe()()`. It's recommended to avoid using these directly, but both `chain()()` and `pipe()()()` use them respectively.

### chainRunner
```typescript
const chainRunner =
  (...actions: BotAction[]): BotAction =>
    async(page, ...injects) => {
      for(const action of actions) {
        await action(page, ...injects)
      }
    }
```

### pipeRunner
```typescript
const pipeRunner = 
  <R extends PipeValue = PipeValue, P extends PipeValue = PipeValue>
  (...actions: BotAction<PipeValue|void>[]): BotAction<PipeValue<R>> =>
    async(page, ...injects) => {
      let pipe: Pipe = createEmptyPipe()

      if (injectsHavePipe(injects)) {
        pipe = getInjectsPipeOrEmptyPipe<P>(injects)
        injects = injects.slice(0, injects.length - 1)
      }

      for(const action of actions) {
        const nextPipeValueOrUndefined: PipeValue|void = await action(page, ...injects, pipe)
        pipe = wrapValueInPipe(nextPipeValueOrUndefined as PipeValue|undefined)
      }

      return pipe.value as any as PipeValue<R>
    }    
```